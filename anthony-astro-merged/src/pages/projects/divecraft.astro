---
import Base from "../../layouts/Base.astro";
---

<Base title="DiveCraft — Case Study (WIP)" description="Final-year WIP: procedural islands, blocky wave simulation, chunk meshing.">
  <h1>DiveCraft — Blocky Waves & Procedural Islands <span style="font-size:.6em;opacity:.8">• WIP (Final-Year Project)</span></h1>

  <p class="muted">
    <strong>Engine:</strong> Unity 2022 LTS &nbsp;•&nbsp; <strong>Language:</strong> C# &nbsp;•&nbsp; <strong>Role:</strong> Solo Developer
  </p>

  <section class="prose">
    <h2>Overview</h2>
    <p>
      DiveCraft is my final-year work-in-progress: a voxel island world with a stylised, block-based wave system and a chunked terrain
      pipeline. Core systems include chunk generation/meshing, a hotbar + block placement/breaking, a water volume mesh,
      and player movement with swim physics.
    </p>

    <h2>Footage</h2>
    <h3>Building</h3>
    <video src="/media/divecraft/videos/building.mp4" autoplay muted loop playsinline></video>
    <h3>Mining</h3>
    <video src="/media/divecraft/videos/mining.mp4" autoplay muted loop playsinline></video>

    <h3>Image Gallery</h3>
    <div class="grid">
      <img src="/media/divecraft/shots/divecraft1.jpg" alt="Generated island view"/>
      <img src="/media/divecraft/shots/divecraft2.jpg" alt="Underwater terrain"/>
      <img src="/media/divecraft/shots/divecraft3.jpg" alt="Terrain layers"/>
    </div>

    <h2>What I built (programmer focus)</h2>

    <h3>Chunked world & generation</h3>
    <ul>
      <li>
        A <strong>Worlds</strong> singleton spawns a grid of chunk GameObjects and keeps a lookup of loaded chunks. It batches creation over frames to avoid stalls.
      </li>
      <li>
        Each <strong>Chunks</strong> instance fills a 16×128×16 voxel array, blends
        an island radial mask with Perlin detail, layers materials (grass/dirt/limestone/stone),
        and fills above terrain with water up to a defined sea level.
      </li>
    </ul>

    <h3>Meshing & materials</h3>
    <ul>
      <li>
        Solid block mesh is built face-by-face only where neighbors are non-solid (air/water), with UVs
        pulled from a block atlas; water uses a separate child “WaterMesh” with its own material/UVs, and
        we skip water-to-water faces for fill-rate.
      </li>
      <li>
        UV helpers, face tables, atlas sizing, and shape flags live in <strong>VoxelData</strong> (e.g., 16×16 chunk width, atlas size = 7, sea level, per-face UV rotation).
      </li>
    </ul>

    <h3>Interaction & player controller</h3>
    <ul>
      <li>
        <strong>PlayerController</strong> does mouse-look + CharacterController movement, block breaking/placing via camera raycasts,
        and swim logic when feet are inside a water block (space to rise, shift to sink faster).
      </li>
      <li>
        <strong>Hotbar</strong> cycles block types, with a simple TMP UI showing the current selection.
      </li>
    </ul>

    <h2>Representative code</h2>

    <pre class="code"><code class="language-csharp">{`// Worlds: spawn chunk grid (batched)
for (int i = 0; i < chunkCoords.Count; i += 8) {
  for (int j = 0; j < 8 && i + j < chunkCoords.Count; j++) {
    var coord = chunkCoords[i + j];
    // new GameObject("Chunk_x_y") + AddComponent<Chunks>() + GenerateChunk()
  }
  // yield return null; // keep frame times smooth
}`}</code></pre>

    <pre class="code"><code class="language-csharp">{`// Chunks: only emit faces against non-solid neighbors (skip water→water)
if (!IsSolid(neighbor)) {
  // choose water or solid mesh buffers
  // add 4 verts, 6 indices, and atlas UVs per visible face
}`}</code></pre>

    <pre class="code"><code class="language-csharp">{`// PlayerController: interact with voxels via camera ray
if (Input.GetMouseButtonDown(0)) TryBreakBlock();
if (Input.GetMouseButtonDown(1)) TryPlaceBlock();`}</code></pre>

    <h2>Results & next steps (WIP)</h2>
    <ul>
      <li>Stable chunked rendering with separate water mesh and atlas UVs.</li>
      <li>Functional placement/breaking, swimming, and hotbar.</li>
      <li><strong>Next:</strong> optimise meshing (greedy merge), expand island variety, add underwater caves & tides, and profiling passes.</li>
    </ul>

    <p><em>Note: This page represents an active, in-progress build for my final-year university project.</em></p>
  </section>
</Base>